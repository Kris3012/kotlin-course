package ru.stimmax.lessons.lesson13.homework

fun main(){

//1. Дан словарь с именем и временем выполнения каждого автоматизированного теста в секундах. Определите среднее время выполнения теста.
    val autotests = mapOf("тест 1" to 5,"тест 2" to 2, "тест 3" to 8)
    var sum = 0
    for((key,value) in autotests.entries){
        sum+= value
        val average = sum / autotests.size.toDouble()
        println(average)
    }

//2. Имеется словарь с метаданными автоматизированных тестов, где ключи — это имена тестовых методов а значения - строка с метаданными. Выведите список всех тестовых методов.
val metaAuto = mapOf("метод 1"  to "метаданные1", "метод 2"  to "метаданные2", "метод 3"  to "метаданные3",)
     println(metaAuto.keys)

//3. В изменяемый словарь с данными о прохождении тестов добавьте новый тест и его результат.
    val autotests2 = mutableMapOf("тест 1" to 5,"тест 2" to 2, "тест 3" to 8)
    autotests2.put("тест 4", 10)

//4. Посчитайте количество успешных тестов в словаре с результатами (ключ - название, значение - результат из passed, failed, skipped).
val passedCount = mapOf("название_1"  to "passed", "название_2"  to "skipped", "название_3"  to "failed",  "название_4"  to "passed")
    val a1 = passedCount.filterValues {it == "passed"}.count()

//5. Удалите из изменяемого словаря с баг-трекингом запись о баге, который был исправлен (ключ - название, значение - статус исправления).
val bugTracking = mutableMapOf("баг1" to "исправлено", "баг2" to "новый", "баг3" to "в работе")
    val a2 = bugTracking.remove("баг1")

//6. Для словаря с результатами тестирования веб-страниц (ключ — URL страницы, значение — статус ответа), выведите сообщение о странице и статусе её проверки.
val testResults = mapOf("http://www.example1.com" to "200 ОК", "http://www.example2.com" to "400 Bad Request", "http://www.example3.com" to "404 Not Found" )
for (entry in testResults.entries){
    println("Key:${entry.key}, Value:${entry.value}")
}

//7. Найдите в словаре с названием и временем ответа сервисов только те, время ответа которых превышает заданный порог.
val responseTime = mapOf("сервис1" to 5.5, "сервис2" to  4.0, "сервис3" to 2.6)
    responseTime.forEach { (service, time) ->
    if (time > 3.0)
    println("$service: $time")
    }

//8. В словаре хранятся результаты тестирования API (ключ — endpoint, значение — статус ответа в виде строки). Для указанного endpoint найдите статус ответа, если endpoint отсутствует, предположите, что он не был протестирован.
val apiResults = mapOf("endpoint1" to "200 ОК", "endpoint2" to "200 ОК")
    apiResults.getOrElse("endpoint3"){println("Endpoint не протестирован")}

//9. Из словаря, содержащего конфигурации тестового окружения (ключ — название параметра конфигурации, значение - сама конфигурация), получите значение для "browserType". Ответ не может быть null.
val testConfig = mapOf("параметр_1" to "конфиг1", "параметр_2" to "конфиг2", "параметр_3" to "конфиг3")
    testConfig.getValue("browserType")

//10. Создайте копию неизменяемого словаря с данными о версиях тестируемого ПО, добавив новую версию.
val testPO = mapOf("ПО_1" to "версия_1", "ПО_2" to "версия_2", "ПО_3" to "версия_3")
    val a4 = testPO + mapOf("ПО_1" to "версия_4")

//11. Используя словарь с настройками тестирования для различных мобильных устройств (ключ — модель устройства, значение - строка с настройками), получите настройки для конкретной модели или верните настройки по умолчанию.
val mobileSettings = mapOf("девайс_1" to "настройки1", "девайс_1" to "настройки1", "девайс_1" to "настройки1")
     mobileSettings.getOrDefault("девайс_2"){"настройки_по_умолчанию"}

//12. Проверьте, содержит ли словарь с ошибками тестирования (ключ - код ошибки, значение - описание ошибки) определенный код ошибки.
val testErrors = mapOf("код ошибки_1" to "описание ошибки_1", "код ошибки_2" to "описание ошибки_2", "код ошибки_3" to "описание ошибки_3")
testErrors.containsKey("код ошибки_2")

//13. Дан неизменяемый словарь, где ключи — это идентификаторы тестовых сценариев в формате "TestID_Version", а значения — статусы выполнения этих тестов ("Passed", "Failed", "Skipped"). Отфильтруйте словарь, оставив только те сценарии, идентификаторы которых соответствуют определённой версии тестов, то-есть в ключе содержится требуемая версия.
val testsIdResults = mapOf("TestID_Version_1" to "Failed", "TestID_Version_2" to "Passed", "TestID_Version_1" to "Skipped")
    val requiredVersion = "1"
    testsIdResults.filterKeys { it.contains(requiredVersion) }

//14. У вас есть словарь, где ключи — это названия функциональных модулей приложения, а значения — результаты их тестирования. Проверьте, есть ли модули с неудачным тестированием.
    //пока пропускаю

//15. Добавьте в изменяемый словарь с настройками тестовой среды настройки из другого словаря.
    val settingsForTest = mutableMapOf("ключ настроек 1" to "значение настроек 1")
    settingsForTest + ("ключ настроек 2" to "значение настроек 2")

//16. Объедините два неизменяемых словаря с данными о багах.
    val bugData1 = mapOf("" to "")
    val bugData2 = mapOf("1" to "2")
    val mutableBugData1 = bugData1.toMutableMap()
    mutableBugData1.putAll(bugData2 )

//17. Очистите изменяемый словарь с временными данными о последнем прогоне автоматизированных тестов.
     val autotestsRunTime = mutableMapOf("прогон 1" to 2.0, "прогон 2" to 2.0, "прогон 3" to 2.9)
    autotestsRunTime.clear()

//18. Исключите из отчета по автоматизированному тестированию те случаи, где тесты были пропущены (имеют статус “skipped”). Ключи - название теста, значения - статус.
val autotestReport = mutableMapOf("TestID_1" to "Failed", "TestID_2" to "Passed", "TestID_3" to "Skipped", "TestID_4" to "Skipped")
    val filteredReport = autotestReport.filterNot { it.value.equals("Skipped", ignoreCase = true) }

//19. Создайте копию словаря с конфигурациями тестирования удалив из него несколько конфигураций.
    //пока пропускаю
//20. Создайте отчет о тестировании, преобразовав словарь с результатами тестирования (ключ — идентификатор теста, значение — результат) в список строк формата "Test ID: результат".
    //пока пропускаю
//21. Преобразуйте изменяемый словарь с результатами последнего тестирования в неизменяемый для архивации.
    //пока пропускаю
//22. Преобразуйте словарь, содержащий числовой ID теста и данные о времени выполнения тестов, заменив идентификаторы тестов на их строковый аналог (например через toString()).
    //пока пропускаю
//23. Для словаря с оценками производительности различных версий приложения (ключи - строковая версия, значения - дробное число времени ответа сервера) увеличьте каждую оценку на 10%, чтобы учесть новые условия тестирования.
    //пока пропускаю
//24. Проверьте, пуст ли словарь с ошибками компиляции тестов.
    val testCompilationsErrors = mapOf("что-то_1" to 2, "что-то_2" to 1, "что-то_3" to 3)
    testCompilationsErrors.isEmpty()

//25. Убедитесь, что словарь с результатами нагрузочного тестирования не пуст.
    val stressTestResults = mapOf("test_1" to "result_1", "test_2" to "result_2", "test_3" to "result_3")
    stressTestResults.isNotEmpty()

//26. Проверьте, прошли ли успешно все автоматизированные тесты в словаре с результатами.
    val testsResults1 = mapOf("result_1" to "Passed", "result_2" to "Passed", "result_3" to "Passed")
    testsResults1.all{it.value.equals("Passed", ignoreCase = true)}

//27. Определите, содержит ли словарь с результатами тестирования хотя бы один тест с ошибкой.
    val testsResults = mapOf("test_1" to "result_1", "test_2" to "result_2", "test_3" to "error")
    testsResults.any{ it.value.equals("error", ignoreCase = true) }

//28. Отфильтруйте словарь с результатами тестирования сервисов, оставив только те тесты, которые не прошли успешно и содержат в названии “optional”.
    //пока пропускаю

}